기존 아키텍처에서 새로운 아키텍처로 어떻게 변경되었는지, 각 기술 요소가 어떤 역할을 담당하는지 명확하게 정리해 드리겠습니다. 이 문서는 프로젝트의 기술 문서를 작성하거나 팀원에게 공유할 때 그대로 사용하실 수 있습니다.

---

## **프로젝트 아키텍처 변경 명세서**

### **1. 목표**

기존의 정적(Static)이고 하드코딩된 데이터를 사용하던 자재 가격 조회 페이지를, 실제 데이터베이스와 연동하여 동적(Dynamic)으로 작동하고, 높은 성능과 유지보수성을 갖춘 데이터 기반 애플리케이션으로 전환하는 것을 목표로 합니다.

### **2. 핵심 기술 스택 및 역할**

이번 아키텍처 변경의 핵심은 **"관심사의 분리(Separation of Concerns)"**입니다. 각 기술이 하나의 책임만 명확하게 갖도록 역할을 분담했습니다.

| 기술 스택                    | 역할                               | 설명                                                                                                                              |
| ----------------------------- | ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| **Supabase Functions (RPC)**  | **백엔드 & 데이터 처리**           | 복잡한 데이터 집계 및 필터링을 데이터베이스 서버에서 직접 처리합니다. 클라이언트의 부담을 최소화하고 성능을 극대화합니다.              |
| **Zustand**                   | **클라이언트 상태 관리 (Client State)** | 사용자의 선택(드롭다운, 날짜)과 같은 UI 상태를 전역적으로 관리합니다. 앱의 "제어판" 역할을 합니다.                                  |
| **React Query (@tanstack/react-query)** | **서버 상태 관리 (Server State)**      | Supabase로부터 데이터를 요청하고, 받아온 데이터를 캐싱(Caching), 동기화, 관리합니다. 데이터 로딩/에러 상태를 자동으로 처리합니다. |
| **Recharts**                  | **데이터 시각화**                  | React Query가 가져온 데이터를 바탕으로 사용자에게 시계열 차트를 렌더링합니다.                                                      |

### **3. 변경된 아키텍처 다이어그램**

데이터와 사용자의 상호작용이 어떤 흐름으로 처리되는지 도식화하면 다음과 같습니다.

```
+--------------------------+
|   사용자 상호작용 (클릭)  |
+--------------------------+
            |
            v
+--------------------------+      1. 사용자가 드롭다운에서 카테고리 선택
|   UI 컴포넌트 (page.tsx)  |
+--------------------------+
            |
            v
+--------------------------+      2. Zustand 스토어의 상태(e.g., selectedLevel1) 변경
|   Zustand (클라이언트 상태) |
+--------------------------+
            |
            v
+--------------------------+      3. Zustand 상태 변경을 감지하고, 해당 상태를 key로 사용하여
|   React Query (서버 상태)   |         자동으로 데이터 재요청(Re-fetch) 트리거
+--------------------------+
            |
            v
+--------------------------+      4. React Query가 Supabase 함수(RPC)를 호출하여
|   Supabase (백엔드/DB)    |         필요한 데이터(e.g., 중분류 목록, 차트 데이터) 요청
+--------------------------+
            |
            v
+--------------------------+      5. Supabase에서 받은 데이터를 캐싱하고, isLoading, data, isError
|   React Query (서버 상태)   |         상태를 UI 컴포넌트에 제공
+--------------------------+
            |
            v
+--------------------------+      6. 최종 데이터를 받아 차트 및 UI 업데이트
|   UI 컴포넌트 (Chart/page)  |
+--------------------------+
```

### **4. 컴포넌트 및 파일별 역할 상세 설명**

#### 가. 백엔드 (Supabase)

*   **`get_price_data` (SQL 함수)**
    *   **역할**: 차트 데이터 집계기.
    *   **작동 방식**: 클라이언트에서 요청한 날짜 범위, 자재 목록, 시간 간격(주간/월간/연간)을 인자로 받아, 거대한 원본 데이터를 서버에서 직접 그룹화하고 평균 가격을 계산하여 **최종 결과물만** 클라이언트에 전달합니다.
    *   **핵심 개선점**: 수만 개의 데이터를 클라이언트로 보내 브라우저를 느리게 만드는 대신, 강력한 데이터베이스 서버가 모든 계산을 끝내므로 클라이언트는 매우 가벼워지고 응답 속도가 빨라집니다.

*   **`get_distinct_categories` (SQL 함수)**
    *   **역할**: 동적 드롭다운 목록 생성기.
    *   **작동 방식**: 상위 카테고리 선택값을 인자로 받아, 해당 조건에 맞는 하위 카테고리의 고유 목록을 반환합니다.
    *   **핵심 개선점**: 하드코딩된 카테고리 목록을 제거하여, 데이터베이스에 새로운 자재가 추가되면 UI가 자동으로 이를 반영하게 됩니다.

#### 나. 프론트엔드 (Next.js / React)

*   **`src/store/materialStore.ts` (Zustand)**
    *   **역할**: 애플리케이션의 **상태 제어 센터**.
    *   **관리 대상**: `selectedLevel1`~`4`, `interval`, `startDate`, `endDate`, `selectedMaterialsForChart` 등 모든 UI 관련 상태.
    *   **핵심 개선점**: `useState`가 여러 컴포넌트에 흩어져 발생하는 복잡성과 "Prop Drilling"(상태를 전달하기 위해 여러 컴포넌트를 거치는 문제)을 해결했습니다. 어떤 컴포넌트든 이 스토어에 직접 접근하여 상태를 읽거나 업데이트할 수 있습니다.

*   **`src/components/materials/MaterialsChart.tsx` (React Query + Recharts)**
    *   **역할**: **데이터 시각화 전문 컴포넌트**.
    *   **작동 방식**:
        1.  Zustand 스토어를 구독하여 현재 사용자가 선택한 자재 목록, 기간 등을 가져옵니다.
        2.  이 정보들을 `queryKey`로 사용하여 `useQuery` 훅을 호출합니다.
        3.  `useQuery`는 `get_price_data` 함수를 호출하여 차트 데이터를 가져옵니다.
        4.  데이터를 가져오는 동안 자동으로 로딩 스켈레톤 UI를, 실패 시 에러 메시지를 보여줍니다.
        5.  성공적으로 데이터를 받으면 Recharts를 사용해 차트를 렌더링합니다.
    *   **핵심 개선점**: 복잡한 데이터 페칭, 로딩/에러 처리, 차트 렌더링 로직을 페이지와 완전히 분리하여 재사용성과 가독성을 높였습니다.

*   **`src/app/materials/page.tsx`**
    *   **역할**: **UI 구조 조립기(Orchestrator)**.
    *   **변경 전**: 모든 상태 관리, 데이터 정의, 로직 처리를 담당하는 거대하고 복잡한 컴포넌트.
    *   **변경 후**:
        1.  Zustand 스토어에서 상태와 상태 변경 함수를 가져옵니다.
        2.  `useCategories` 훅(React Query)을 통해 각 드롭다운에 필요한 목록 데이터를 가져옵니다.
        3.  가져온 데이터와 상태를 각 UI 컴포넌트(Select, Button 등)에 연결합니다.
        4.  `MaterialsChart` 컴포넌트를 배치합니다.
    *   **핵심 개선점**: 자체적으로 상태나 복잡한 로직을 거의 갖지 않고, 각 전문 컴포넌트(드롭다운, 차트)를 조립하고 배치하는 역할만 수행하여 코드가 매우 간결하고 명확해졌습니다.

*   **`src/app/providers.tsx` 및 `layout.tsx`**
    *   **역할**: **애플리케이션의 기반 설정**.
    *   **작동 방식**: 앱 전체를 `QueryClientProvider`로 감싸, 모든 하위 컴포넌트에서 React Query의 기능(캐싱, 훅 사용 등)을 사용할 수 있도록 환경을 설정합니다.
    *   **핵심 개선점**: React Query의 강력한 기능을 프로젝트 전역에서 일관되게 사용할 수 있는 토대를 마련합니다.

### **5. 주요 개선 사항 요약**

1.  **성능 향상**: 무거운 데이터 집계 연산을 서버(Supabase)로 이전하여 클라이언트(브라우저)의 부담을 크게 줄였고, 초기 로딩 및 상호작용 속도가 향상되었습니다.
2.  **유지보수성 및 확장성**: 역할별로 코드를 분리(Zustand, React Query, UI 컴포넌트)하여 특정 기능을 수정하거나 추가할 때 다른 코드에 미치는 영향이 최소화되었습니다.
3.  **데이터 동기화**: DB에 데이터가 변경되면, 별도의 코드 수정 없이 UI(드롭다운, 차트)가 다음 데이터 요청 시 자동으로 최신 정보를 반영합니다.
4.  **향상된 사용자 경험(UX)**: React Query가 자동으로 로딩 및 에러 상태를 관리해주어 사용자에게 현재 앱의 상태를 명확하게 피드백할 수 있습니다. 또한, 캐싱 기능 덕분에 불필요한 네트워크 요청이 줄어들어 전반적인 사용성이 개선됩니다.